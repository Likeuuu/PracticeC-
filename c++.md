# 八股文

### 两大正交系统

- 类型:
  - T
  - T &
  - T &&
- 值类别
  - lvalue
  - xvalue
  - prvalue

---

### 左值lvalue,右值prvalue,将亡值xvalue, 以及move

- 什么是lvalue?

  - 有内存, 有地址, 有名字, 生命周期清晰--有身份

- 什么是prvalue?

  - 无地址, 临时对象, 用完就毁

- 什么是xvalue?

  - 需要std::move(x) 把左值(有身份)变成将亡值

  - **承诺**以后**不再**使用的值，可以安全**偷它的资源**

- move的作用?

  - 避免高昂的内存拷贝

  - 把左值,强制变为xvalue

  - 新的变量接管旧变量管理的内存, 而旧变量不再管理(可能为nullptr)

- 注意:

  - ~~~c++
    // r 是左值(有名字), 但它是右值引用
    int&& r = 10;
    
    void foo(int&& x)
    { 
        // 在函数内, x 为左值. 不在乎外面传入右值
    }
        
    foo(10);
    foo(std::move(r));
    ~~~



---

### 引用折叠规则

- T&  &   → T&
- T&  &&  → T&
- T&& &   → T&
- T&& &&  → T&&



---

### 函数形参的 左值 与 右值 (普通情况, 非万能引用情况)

- void handle(A& a)     -- 意味着 **借用型接口**
  - **目的**: 保持对象外部状态, 不能随意 move 资源 
- void handle(A&& a)  -- 意味着 **消耗型接口**
  - **目的**: 改变对象**内部状态**, 可 move 资源 
  - 接收类型 : 
    - 临时
    - move

---

### Move

~~~c++
A a;

viod handle(A&& a)
{
};


// std::mvoe(a) 其实是 static_cast<A&&>(a)

// 1.能够传入 handle 函数
handle(std::move(a);
       
// 2.
A b = std::move(a);  // 等价于 A b(static_cast<A&&>(a))  -- 触发移动构造
~~~

---

### RAII

- **目的** : 把“必须成对出现的操作”， 绑定到**对象生命周期**，由编译器 + 语言规则保证
  - 例如 : 让资源的生命周期管理, 放在构造/析构声明. 
    - 内存
    - 锁
    - 文件 / socket / fd
    - 网络连接
    - 等等
  - 这样Class 的对象在离开作用域触发析构, 资源自动释放
    -  (避免忘记写free)
    -  发生异常后, 不走 free -- 造成泄露



---

### 类 Class

- **目的**: 用于定义数据结构

  - 生命周期规则（构造 / 析构 / 拷贝 / 移动）
  - 状态（数据）
  - 行为（操作）  
  - 使用语义（值语义 / 资源语义/共享所有权语义 -- 可能不准确
    - 什么是使用语义: 使用者“应该如何理解、如何使用、如何拷贝这个类型”
    - 值语义 : 像 `int`，拷贝后互不影响
    - 资源语义 : 像 unique_ptr 一样,  资源的所有权**只能被一个**对象持有
    - 共享所有权语义 : 像 shared_ptr 一样, 多个引用资源. 最后一个引用结束才进行析构

- 设计**焦点**: 

  - 像内置类型一样地自然, 而不是带方法的struct

    - 什么是像内置类型一样地自然?

      - 可以：

        - 拷贝

        - 赋值

        - 比较

        - 放进表达式

        - **不用关心内部细节**

        - ~~~c++
          int a = 3;
          int b = 4;
          int c = a + b;
          
          if (a < b) { }
          
          a = b;
          ~~~

    - 如何实现?

      - 析构/构造
      - 运算符重载
      - 拷贝 /移动   构造/ 赋值

---

### C++ 初始化

- 为了避免隐形转换, 引入 {}

~~~c++
// 1. 全局/静态  自动作初始化

// 2. 未初始化, 垃圾值
int a;

// 3. 拷贝初始化  -- 可能隐转问题
int a = 10;

// 4. 直接初始化  -- 匹配构造函数, 降低隐转问题
int a(10);

// 5. 列表初始化  -- 不存在隐转问题
int a{}; int a = {} 
MyStruct obj{1,2.0};

// 6. 动态初始化
int* p = new int(10);   // 初始化为 10
int* q = new int;       // ❌ 未初始化
int* r = new int{};     // ✅ 初始化为 0
~~~

- 工程建议:⭐⭐⭐⭐⭐

  - 没有特别需求, 尽量初始化, 尽量用 {} 去初始化 --- 甚至是**强制**初始化

  - ~~~c++
    struct RlcCtx {
        uint32_t sn;
        bool     running;
    };
    
    RlcCtx ctx;     // ⚠️ sn / running 未初始化
    RlcCtx ctx_1{};   // ✅ 推荐写法  所有成员清零
    ~~~

- 反码补码的**意义**?

  - 在有符号才有效
  - 反码的意义 : 为了表示负数
  - 补码的意义: 为了更好的表示负数

- size_t capacity()  **const**; 为什么要**加const? **✅

  - 防止为const类时, **无法访问**该函数
  - 表示该函数**不会改变**该对象自身变量 (调用该函数的this, **此时**是 const Buffer* const this)
  - **const** size_t capacity()  **const** 可以吗; ✅
    - 第一个对 size_t 加 const 毫无意义, 只有引用/指针才有意义

- const

  - const + 函数

    - 返回类型前: const T f();
      - T 为指针/引用才有意义, 其它类型没有意义.
    - 函数名后: T f() const;
      - 表示当前调用该函数对象this, **此刻**为  const Buffer* const this

  - const + 变量 -- 永远是对类型进行 const

    - const 修饰从左到右

      - const + 普通类型 :const int a = 10 ;  int const  a = 10 ;

        - 为什么等效?  ✅

      - const + 指针  : 

        - ~~~c++
          // 区别
          // 以下等效, 修饰指向的内容
          const int * k;
          int const* p;
          
          // 修饰q 本身
          int* const q; 
          
          // 最后的例子
          const int* const p = &x;
          ~~~

      - const + 引用  :  const int& r = x;

        - 为什么没有 int& const  r = x;? ✅

      - const + 数组:  const int arr[3] = {1,2,3}; // 修饰的是数组元素

        - 为什么只能对数组元素类型进行const? ✅

      - const  变量 **需要在**构造列表初始化

        - **为什么?**  ✅

    - 总体感觉 **const 修饰 就是**去掉 基本类型后的**场景**

  - aligned_alloc 和 malloc 区别?

    - malloc : 用系统默认的字节对齐
    - aligned_alloc: 指定字节对齐
      - 场景: cache line 对齐,  指令 SIMD
      - 注意:
        - std::aligned_alloc(alignedment,  size) : 
          - 理解两个参数的现实意义
          - size **一定是** alignedment的倍数

  - 为什么 static 的函数定义和声明应该放在同一文件夹下(.h)?

    - static 函数的符号表是 LOCAL. 放在.cpp 会导致其它文件链接不到该定义

---

### 问题:

- && 能接收左值吗 ? --待完善⭐

  - 普通不能

- - 

  - 但在“模板 + 类型推导 T&&”时可以 -- **转发引用**  --能保留左值右值属性, 完美转发的基础

    - ~~~c++
      template <typename T>
      void f(T&& x)
      
      int a = 10;
      
      f(a);        //  这里传的是左值
      f(10);       //  这里传的是右值
      // 都合法
      
      // 仅限入参  T&& x, 才能根据入参推导 T
      ~~~



- `**auto&&**` 本质上也是转发引用
  - 不是“我想要一个右值引用”, 而是能绑定任何东西，并**保持其值类别**的引用
- 为什么有编译和链接?
- 为什么声明和定义分开就可以独立编译?
- extern 的用法?

---

# C++ Primer

## 第一章 开始

### for 与 while 的应用场景

- for : 知道要循环什么
- while : 只关心什么时候停
- 本质没区别

---

### 风格

- 引用时, 对于系统库用<>. 对于自己的库用 " "
- 缩进, 大括号的代码,  需要做到 项目级别 的统一

---

## 第二章 变量与基本类型

C++是**静态**语言, 在编译时就知道类型

C++提供基本的类型, 就能满足开发者自定义数据结构的需求

**1 byte = 0XFF = 255**

---

### 内置类型 -- 关系到内存怎么padding

- 算数类型

  - 整型 (****有符号/无符号)

  - 浮点型 (**仅**有符号)

    - **分** float (1个字), double(2个字), long double(3/4 个字)

    - **工程**一般用 double.   性能/内存明确需要时, 用 float

    - 注意:

      - 2进制无法精确表示浮点, 所以**不能**作**精确比较 == **

        - if (a == b)   // ❌ 错
        - if (progress == 1.0)   // ❌

      - **不要**把浮点与整数**混用**

        - double len = 1024;  len += 1;   // ❌ 逻辑隐患

      - 精度会**逐步**累积**误差**

        - ~~~c++
          double x = 0;
          for (int i = 0; i < 1000000; ++i)
              x += 0.1;
          // 理论是 100000
          // 实际会有误差
          ~~~

      - 浮点表示大值时, **精度逐渐丢失**

      - NaN / Inf **会悄悄传播**

        - ~~~c++
          double x = 0.0 / 0.0;  // NaN
          double y = x + 1;     // 还是 NaN
          ~~~

      - **隐式**类型**转换会改变**精度

        - ~~~c++
          float f = 1e20;    // 已经溢出精度
          double d = f;      // 精度已经丢失，补不回来
          ~~~
- 空类型

  - NULL 和 nullptr 的**区别**

    - NULL :冒充指针的整数0, 本质是**宏**

      - 入参会被解析成int

    - nullptr : **真正**的空指针

      - 只能表示空指针
      - 不会被当整数
      - 重载/模板安全

    - ~~~c++
          int* p = NULL;   // 本质是 p = 0;
      
      
          printf("  p : %d, \n", p);  // 不能用 %d 打印 指针地址
          printf("  p : %p, \n", p);  // OK
          printf(" *p : %d \n", *p);  // crash : 解引用一个空指针
      ~~~

---

### 如何选择类型

- 整型
  - bool / char : 
    - **不要参与**运算
    - char 在不同平台能识别为 无符号/有符;  所以**需要指明**unsigned/ signed char
  - 其它整型: 
    - 明确非负数就用无符号
    - 明确几位就几位
- 浮点型
  - **推荐**用double (更精确, 且性能差不多)

---

### 如何避免依赖环境

- 问题 : 同代码不同平台, 同平台同代码不同时间 **跑出不同**情况
- 解决办法
  - 使用明确字宽类型
    - int32_t
      - 问题 : **千万不能**越界
      - 解决办法 :
        -  边界检测
        - 用更大类型作中间值运算
    - uint32_t
      - 问题 : 小心环绕
      - 解决办法:
        -  定义函数去作上下文背景计算

---

### 初始化和赋值的区别

- 初始化: 创建变量就赋予初始值
- 赋值: 擦除旧值, 赋予新值
- 为什么int a = 10; a = 20; 分别是初始化和赋值呢?
  - C语言历史包袱, C 语言 int a = 10 ; 就是初始化. 
  - 编译器**如何区分**呢?
    - C++的 operator = 为**赋值**
    - 在创建新对象时 = 被理解从初始化
    - 对已有对象的 = 被理解成赋值

### 声明与定义

- 目的 : 支持分离式编译, 使每个文件能独立编译
  - 声明 :满足编译
  - 定义: 满足链接, 
    - 告诉链接器 **符号**foo(int) (**申明**)的**实体**(**定义**)在哪里
- 区别:
  - 声明: 
    - 只规定类型和变量名
    - 可以多次
  - 定义: 
    - 规定类型和变量名 + 申请空间
    - 只能一次
- 如何辨认?
  - 与初始化大体相同: 初始化就是定义. 无初始化就是声明
- 函数体内部初始化一个extern关键字的变量, 会引起错误

---

### 复合类型

 ~~~c++
 int a; 
 // 一般理解成 数据类型 + 变量列表
 
 int (*fp)(int);
 // 设计理念解释 : 基本数据类型 + 声明符. 声明符:命名了一个变量,并指定变量为与基本数据类型相关的某种类型
 ~~~



#### 引用

- 引用就是别名, 并**不是对象**
  - 注意:
    - C++的设计是 引用必须进行初始化, 不然会对赋值产生影响

#### 指针

- 对内存进行操作的**对象**
  - 注意
    - 有4种状态
    - 访问无效指针**后果很严重**
    - 指针与bool**一样**, 保持的地址值非0就是true



---

#### 为什么设计指针和引用

指针: 主要为**访问内存**而设计, 还可以提前用空指针**占位**, 为之后调用作占位

引用: 主要是一种语法**约束**, 约定对象一定**非空**, **不能重**新绑定等\

区别:

- 指针是对象, 可以重新绑定
- 是否需要初始化



---

### 内置类型的机器实现

机器内存中, **最小单位**是字节. 

计算机读取单位是 **字** : 根据自己的位数  32/64.  **读取N个** 4 字节 / 8 字节的数据 

那字节对齐又是啥?

- C/C++ 语言 + ABI 层面的概念
  - 为了每次正确的把变量填充到内存上. 字**只是更底层**的读取单位而已
    - **限制**每个变量的起始地址

~~~c++
struct alignas(16) S {
    int     a;   // 4 bytes
    double  b;   // 8 bytes
    char    c;   // 1 byte
};

// 在 32/64 位机器上：
| a | a | a | a | i | i | i | i | b | b | b | b | b | b | b | b |
| c | i | i | i | i | i | i | i | i | i | i | i | i | i | i | i |
    
// 为什么 double 需要从 地址 % 8 == 0 地方开始?
// 实现函数: aligned_offset = (offset + alignment - 1) & ~(alignment - 1);

~~~
